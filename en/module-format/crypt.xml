<?xml version='1.0' encoding='ISO-8859-1'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<!-- $Id: crypt.xml,v 1.2 2010-05-10 14:58:04 mae Exp $ -->

<section id="crypt-module">

    <title>Crypt Module</title>

    <para>
There are two crypt classes in otrs PGP and SMIME. Theoretically you can write your own encryption class.
    </para>
    <section id="example-module-code">
        <title>Interface</title>
        <para>
            You can find the crypt backends the directory Kernel/System/Crypt/.
            They are called by an class Kernel::System Crypt that provides a file template object.
            If you want to write a new encryption class you have to write at least the methods
            crypt, decrypt sign, check and verify.
            You find as example a part of the of the PGP implementation below.
        </para>
        <para>
        <programlisting language="perl" linenumbering="numbered"><![CDATA[
# --
# Kernel/System/Crypt/PGP.pm - the main crypt module
# Copyright (C) 2001-2010 OTRS AG, http://otrs.org/
# --
# $Id: crypt.xml,v 1.2 2010-05-10 14:58:04 mae Exp $
# --
# This software comes with ABSOLUTELY NO WARRANTY. For details, see
# the enclosed file COPYING for license information (AGPL). If you
# did not receive this file, see http://www.gnu.org/licenses/agpl.txt.
# --

package Kernel::System::Crypt::PGP;

use strict;
use warnings;

use vars qw($VERSION);
$VERSION = qw($Revision: 1.2 $) [1];

=head1 NAME

Kernel::System::Crypt::PGP - pgp crypt backend lib

=head1 SYNOPSIS

This is a sub module of Kernel::System::Crypt and contains all pgp functions.

=head1 PUBLIC INTERFACE

=over 4

=cut

=item Check()

check if environment is working

    my $Message = $CryptObject->Check();

=cut

sub Check {
    my ( $Self, %Param ) = @_;

    my $GPGBin = $Self->{ConfigObject}->Get('PGP::Bin') || '/usr/bin/gpg';
    if ( !-e $GPGBin ) {
        $Self->{LogObject}->Log(
            Priority => 'error',
            Message  => "No such $GPGBin!",
        );
        return "No such $GPGBin!";
    }
    elsif ( !-x $GPGBin ) {
        $Self->{LogObject}->Log(
            Priority => 'error',
            Message  => "$GPGBin not executable!",
        );
        return "$GPGBin not executable!";
    }
    return;
}

=item Crypt()

crypt a message

    my $Message = $CryptObject->Crypt(
        Message => $Message,
        Key     => $PGPPublicKeyID,
    );

=cut

sub Crypt {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $ParamName (qw( Message Key )) {
        if ( !$Param{$ParamName} ) {
            $Self->{LogObject}->Log( Priority => 'error', Message => "Need $ParamName!" );
            return;
        }
    }

    # since the following write would auto-convert utf8-characters into iso-characters, we
    # avoid that by explicitly encoding utf8-strings:
    #    if ( utf8::is_utf8( $Param{Message} ) ) {
    #        utf8::encode( $Param{Message} );
    #    }
    $Self->{EncodeObject}->EncodeOutput( \$Param{Message} );

    my ( $FH, $Filename ) = $Self->{FileTempObject}->TempFile();
    print $FH $Param{Message};
    close $FH;

    my ( $FHCrypt, $FilenameCrypt ) = $Self->{FileTempObject}->TempFile();
    close $FHCrypt;
    my $GPGOptions
        = "--always-trust --yes --encrypt --armor -o $FilenameCrypt -r $Param{Key} $Filename";
    my $LogMessage = qx{$Self->{GPGBin} $GPGOptions 2>&1};

    # error
    if ($LogMessage) {
        $Self->{LogObject}->Log(
            Priority => 'error',
            Message  => "Can't crypt with Key $Param{Key}: $LogMessage!"
        );
        return;
    }

    # get crypted content
    my $CryptedDataRef = $Self->{MainObject}->FileRead( Location => $FilenameCrypt );
    return $$CryptedDataRef;
}

=item Decrypt()

Decrypt a message and returns a hash (Successful, Message, Data)

    my %Result = $CryptObject->Decrypt(
        Message => $CryptedMessage,
    );

The returned hash %Result has the following keys:

    Successful => '1',        # could the given data be decrypted at all (0 or 1)
    Data       => '...',      # the decrypted data
    KeyID      => 'FA23FB24'  # hex ID of PGP-(secret-)key that was used for decryption
    Message    => '...'       # descriptive text containing the result status

=cut

sub Decrypt {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(Message)) {
        if ( !defined( $Param{$_} ) ) {
            $Self->{LogObject}->Log( Priority => 'error', Message => "Need $_!" );
            return;
        }
    }

    my ( $FH, $Filename ) = $Self->{FileTempObject}->TempFile();
    print $FH $Param{Message};
    close $FH;

    my %PasswordHash = %{ $Self->{ConfigObject}->Get('PGP::Key::Password') };
    my @Keys = $Self->_CryptedWithKey( File => $Filename );
    my %Return;

    KEY:
    for my $Key (@Keys) {
        my $Password = $Param{Password} || $PasswordHash{$Key} || '';
        %Return = $Self->_DecryptPart(
            Filename => $Filename,
            Key      => $Key,
            Password => $Password,
        );
        last KEY if $Return{Successful};
    }
    if ( !%Return ) {
        return (
            Successful => 0,
            Message    => 'gpg: No private key found to decrypt this message!',
        );
    }
    return %Return;
}

=item Sign()

sign a message

    my $Sign = $CryptObject->Sign(
        Message => $Message,
        Key     => $PGPPrivateKeyID,
        Type    => 'Detached'  # Detached|Inline
    );

=cut

sub Sign {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(Message Key)) {
        if ( !$Param{$_} ) {
            $Self->{LogObject}->Log( Priority => 'error', Message => "Need $_!" );
            return;
        }
    }
    my %PasswordHash = %{ $Self->{ConfigObject}->Get('PGP::Key::Password') };
    my $Pw = $PasswordHash{ $Param{Key} } || '';
    my $SigType
        = $Param{Type} && $Param{Type} eq 'Detached'
        ? '--detach-sign --armor'
        : '--clearsign';

    # create tmp files
    my ( $FH, $Filename ) = $Self->{FileTempObject}->TempFile();
    close $FH;
    my ( $FHSign, $FileSign ) = $Self->{FileTempObject}->TempFile();
    close $FHSign;
    $Self->{MainObject}->FileWrite(
        Location => $Filename,
        Content  => \$Param{Message},
        Mode     => $Param{Charset} && $Param{Charset} =~ /utf(8|\-8)/i ? 'utf8' : 'binmode',
    );

    my ( $FHPhrase, $FilePhrase ) = $Self->{FileTempObject}->TempFile();
    print $FHPhrase $Pw;
    close $FHPhrase;
    my $GPGOptions
        = qq{--passphrase-fd 0 --default-key $Param{Key} -o $FileSign $SigType $Filename};
    my $LogMessage = qx{$Self->{GPGBin} $GPGOptions <$FilePhrase 2>&1};

    # error
    if ($LogMessage) {
        $Self->{LogObject}->Log(
            Priority => 'error',
            Message  => "Can't sign with Key $Param{Key}: $LogMessage!"
        );
        return;
    }

    # get signed content
    my $SignedDataRef = $Self->{MainObject}->FileRead(
        Location => $FileSign,
        Mode => $Param{Charset} && $Param{Charset} =~ /utf(8|\-8)/i ? 'utf8' : 'binmode',
    );
    return $$SignedDataRef;
}

=item Verify()

verify a message signature and returns a hash (Successful, Message, Data)

Inline sign:

    my %Result = $CryptObject->Verify(
        Message => $Message,
    );

Attached sign:

    my %Result = $CryptObject->Verify(
        Message => $Message,
        Sign    => $Sign,
    );

The returned hash %Result has the following keys:

    SignatureFound => 1,        # was a signature found at all (0 or 1)
    Successful     => 1,        # could the signature be verified (0 or 1)
    KeyID          => 'FA23FB24'  # hex ID of PGP-key that was used for signing
    KeyUserID      => 'username <user@test.org>'  # PGP-User-ID (e-mail adress) used for signing
    Message        => '...'       # descriptive text containing the result status
    MessageLong    => '...'       # full output of GPG binary

=cut

sub Verify {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{Message} ) {
        $Self->{LogObject}->Log( Priority => 'error', Message => 'Need Message!' );
        return;
    }

    my ( $FH, $File ) = $Self->{FileTempObject}->TempFile();
    binmode($FH);
    print $FH $Param{Message};
    close $FH;

    my $GPGOptions = '--verify';
    if ( $Param{Sign} ) {
        my ( $FHSign, $FilenameSign ) = $Self->{FileTempObject}->TempFile();
        binmode($FHSign);
        print $FHSign $Param{Sign};
        close $FHSign;
        $GPGOptions .= " $FilenameSign";
    }
    my %Return;
    my $Message = qx{$Self->{GPGBin} $GPGOptions $File 2>&1};
    if ( $Message =~ m{(Good signature from ".+?")}i ) {
        my $GPGMessage = $1;
        my $KeyID      = '';
        if ( $Message =~ m{\s+ID\s+([0-9A-F]{8})}i ) {
            $KeyID = $1;
        }
        else {
            $Self->{LogObject}->Log(
                Priority => 'error',
                Message  => 'Unable to fetch key-ID from gpg output!'
            );
        }
        my $KeyUserID = '';
        if ( $Message =~ m{Good signature from "(.+?)"}i ) {
            $KeyUserID = $1;
        }
        else {
            $Self->{LogObject}->Log(
                Priority => 'error',
                Message  => 'Unable to fetch key-user-ID from gpg output!'
            );
        }
        %Return = (
            SignatureFound => 1,
            Successful     => 1,
            Message        => "gpg: $GPGMessage",
            MessageLong    => $Message,
            KeyID          => $KeyID,
            KeyUserID      => $KeyUserID,
        );
    }
    else {
        %Return = (
            SignatureFound => 1,
            Successful     => 0,
            Message        => $Message,
        );
    }
    return %Return;
}
    ...

        ]]></programlisting>
        </para>
    </section>
    <section id="example-module-configuration">
        <title>Configuration example</title>
        <para>
            There is no need to activate your custom encryption module as long you don't
            alter the class Kernel::System Crypt. To provide your encryption module with options
            to an external binary you can use the following xml configuration:
        </para>
        <para>
        <programlisting language="xml" linenumbering="numbered"><![CDATA[
<ConfigItem Name="OwnModule::Options" Required="1" Valid="1">
    <Description Lang="en">Options for OwnModule binary.</Description>
    <Description Lang="de">Optionen f√ºr das OwnModule Binary.</Description>
    <Group>Framework</Group>
    <SubGroup>Crypt::OwnModule</SubGroup>
    <Setting>
        <String Regex="">--homedir /opt/otrs/.ownmodule/ --batch --no-tty --yes</String>
    </Setting>
</ConfigItem>
        ]]></programlisting>
        </para>
    </section>
    <section id="example-module-use_cases">
        <title>Use case examples</title>
        <para>
Useful crypt backends could be to create your own encryption data.
For example you may want a md5 and a base64 encryption to protect data with two encryption types.
        </para>
    </section>
    <section id="example-module-releases">
        <title>Release Availability</title>
        <para>
The crypt module is available since OTRS 1.3.
        </para>
    </section>
</section>
